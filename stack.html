<html>
<head>
<title>:::C++ структури:::</title>
<meta http-equiv="Content-Type" content="text/html" charset="utf-8">
<script type="text/javascript" src="textsizer.js">
/***********************************************
SKRIPTA ZA GOLEMI I MALKI BUKVI
***********************************************/
</script>
<style type="text/css">
#menu1 a {color:black;background-color:white;text-decoration:none;text-indent:1ex;}
#menu1 a:active {color:black;text-decoration:none;}
#menu1 a:hover {color:black;background-color:#B8FFF1}
#menu1 a:visited {color:black;text-decoration:none;}

</style>
<script src="mmenu.js" type="text/javascript"></script>
<script src="menuItems.js" type="text/javascript"></script>

  <style>
       BODY {
              scrollbar-arrow-color:FFFFFF;
              scrollbar-3dlight-color:FFFFFF;
              scrollbar-face-color:005555;
              scrollbar-darkshadow-color:005555;
              scrollbar-track-color:86A49B;
              scrollbar-highlight-color:FFFFFF;
              scrollbar-shadow-color:FFFFFF;
            }
    </style>




</head>
<body background="pics/background.jpg">
<center>
<table border="0" bordercolor="#A3558E" width="75%" bgcolor="#015756">
<tr>
<td>
 <p align="center"> <font color="#000000" size="+3" face="Verdana"><strong><font color="#42A994">Стекове</font> </strong> </font> </p>
              
              <font color="#FFFFFF" size="-0" face="Verdana"><img src="pics/LetterCcc.jpg" width="50" height="31" align="left">
			  тек се нарича списък, при който добавянето на нови елементи, както и изключването, стават само от 
			  едната страна на списъка – върха на стека. Мнемоника за запомняне на стек е LIFO (last in, first out). 
			  Пример – пълнител на автомат. Пълнителят на автомат е вид стек. Със сигурност най-мъжественият вид стек.
                </font>
				<br><br>
				
<font color="#FFFFFF" size="-0" face="Verdana">
			  Аналог по функционалност на стека е купчина чинии: (на английски куп(чина) е stack) - виж двете 
			  картинки по-долу.
			  <br><br> <center><img src="pics/stack1.jpg">  <img src="pics/stack2.jpg"> </center> <br><br>
			  Последната поставена чиния в купчината е първата, която може да се вземе. Това е реализация на принципа - "Последен вътре, първи вън".
			  Дефиницията на класа е дадена по-долу: <br>
<pre>
class Stack                   // a stack holds up to 20 ints 
{ 
   private: 
      int st[20];             // integers are stored in array 
      int top;                // index of last item pushed 

   public: 
      void init()             // initialize index 
      { 
         top = -1; 
      } 

      void push(int var)      // place an item on the stack 
      { 
         st[++top] = var; 
      } 

      int pop()              // remove an item from the stack 
      { 
         return st[top--]; 
      } 
}; 
</pre> <br>
<font color="#FFFFFF" size="-0" face="Verdana"><i>Свали пример:</i></font> <br><br>
<a href="examples/stack.cpp"><img src="pics/download_button.gif"></a> <br><br>
              Вкараните стойности се пазят в масив от 20 елемента с име <strong>st</strong>, а целочислената променлива <strong>top</strong> 
			  показва коя е текущата стойност в стека: в смисъл, кой елемент от масива е със стойност, вкарана 
			  преди малко: идеята е да имаме достъп само до този същия елемент. Стекът има нужда от инициализация, 
			  която се извършва с функцията <strong>init()</strong> и която се състои в приравняване на променливата <strong>top</strong> на -1. 
			  Вкарването на стойности става с процедурата <strong>push</strong>. С присвояването <strong>st[++top] = var</strong> се извършват две 
			  неща: първо променливата <strong>top</strong> нараства с единица и така сочи към следващия елемент на масива <strong>st</strong>, и второ, 
			  променливата <strong>var</strong> се присвоява на елемента на масива <strong>st</strong>, който е посочен от новата стойност на <strong>top</strong>. Функцията 
			  <strong>pop()</strong> връща последния вкаран в стека елемент с помощта на твърдението <strong>return st[top--]:</strong> забележете, че 
			  първо се връща текущия елемент, а после указателят <strong>top</strong> се намалява с единица и така той сочи към предишно 
			  вкарания елемент. Разбира се, няма защита от четене след връщане на всички елементи (например, опит за 
			  четене на <strong>st[-1])</strong>, ето защо потребителят трябва да се погрижи за изкарване на толкова елементи от стека 
			  (или не повече от тях), колкото са вкарани. <br> <br>
			  Друг пример: <br><br>
<pre>
// stack1.cpp 
// class models a stack 

#include <iostream.h> 
#include <conio.h>            // for getche() 

class Stack                   // a stack holds up to 20 ints 
{ 
   private: 
      int st[20];             // integers are stored in array 
      int top;                // index of last item pushed 

   public: 
      void init()             // initialize index 
      { 
         top = -1; 
      } 

      void push(int var)      // place an item on the stack 
      { 
         st[++top] = var; 
      } 

      int pop()               // remove an item from the stack 
      { 
         return st[top--]; 
      } 
}; 

void main() 
{ 
   Stack s1;                  // create a stack object 

   s1.init();                 // initialize it 
   s1.push(11);               // push 3 items onto stack 
   s1.push(12); 
   s1.push(13); 

   cout << s1.pop() << endl;   // pop 3 items and display them 
   cout << s1.pop() << endl; 
   cout << s1.pop() << endl; 

   // stop the flow on the monitor 
   getch(); 

}  //end main
</pre>
<br><font color="#FFFFFF" size="-0" face="Verdana"><i>Свали пример:</i></font> <br><br>
<a href="examples/stack1.cpp"><img src="pics/download_button.gif"></a> <br><br>
                       В главната функция се създава една променлива s1 от класа Stack. Тя се инициализира с 
                       твърдението s1.init() и последователно в нея се вкарват числата 11, 12 и 13 чрез използване на функцията s1.push() в 
                       следващите три реда. А следващите три програмни реда използват функцията s1.pop() за да изкарат числата от стека. 
                       Обърнете внимание, че редът на излизане на елементите от стека (и на екрана) е следният: <br>
					   <font color="#A3558E">
13 <br>
12 <br>
11 <br>                </font>
т.е. напълно обратен на реда, по който бяха вкарани. 
Разбира се, това бе една елементарна илюстрация на програмната структура (конструкция) стек, която за 
програмиста наподобява функционалността на стек. Въпреки наличието на масив като променлива на класа, 
програмистът борави само с трите функции на класа, без да се обръща директно към масива st. Казано с 
други думи класът Stack опакова (wraps) масива и осигурява интерфейс към него. Това е обща черта на 
класовете в ООП - те създават нов интерфейс (връзка) между програмиста и данните. Много добър пример 
за това опаковане е използването на класовете за осигуряване на интерфейс към API функциите на Windows 
(Windows Application Program Interface functions) с множество от лесни за употреба класове и техни функции. <br>
Накрая ще споменем, че така дефинираният обект има нужда от инициализация, която се извършва с функцията 
init(). Тази функция винаги трябва да се извиква след създаване на обект от класа Stack. На практика, тя е 
недодялана версия на т.н. конструктор. За разлика от конструктора, който се изпълнява винаги, когато се създава 
обект от даден клас (например с декларацията Stack s1;),  програмистът трябва да се погрижи да не изпусне 
извикването на функцията init() след създаване на обекта с Stack s1;. <br>
                </font>
				<br><br>

</tr>
</td>
</table>
</center>
<script>
if (!document.layers)
document.write('<div id="divStayTopLeft" style="position:absolute">')
</script>

<layer id="divStayTopLeft">

<!--EDIT BELOW CODE TO YOUR OWN MENU-->
<table border="2" width="130" cellspacing="0" cellpadding="0">
  <tr>
    <td width="100%" bgcolor="#42A994">
      <p align="center"><b><font size="4" color="#A3558E">Размер</font></b></td>
  </tr>
  <tr>
    <td width="100%" bgcolor="white">
      <p align="left"> <a href="javascript:ts('body',1)">+ Larger Font</a> <br>
       <a href="javascript:ts('body',-1)">+ Smaller Font</a> </td>
  </tr>
</table>
<!--END OF EDIT-->

</layer>


<script type="text/javascript">

/*
Floating Menu script-  Roy Whittle (http://www.javascript-fx.com/)
Script featured on/available at http://www.dynamicdrive.com/
This notice must stay intact for use
*/

//Enter "frombottom" or "fromtop"
var verticalpos="frombottom"

if (!document.layers)
document.write('</div>')

function JSFX_FloatTopDiv()
{
	var startX = 3,
	startY = 150;
	var ns = (navigator.appName.indexOf("Netscape") != -1);
	var d = document;
	function ml(id)
	{
		var el=d.getElementById?d.getElementById(id):d.all?d.all[id]:d.layers[id];
		if(d.layers)el.style=el;
		el.sP=function(x,y){this.style.left=x;this.style.top=y;};
		el.x = startX;
		if (verticalpos=="fromtop")
		el.y = startY;
		else{
		el.y = ns ? pageYOffset + innerHeight : document.body.scrollTop + document.body.clientHeight;
		el.y -= startY;
		}
		return el;
	}
	window.stayTopLeft=function()
	{
		if (verticalpos=="fromtop"){
		var pY = ns ? pageYOffset : document.body.scrollTop;
		ftlObj.y += (pY + startY - ftlObj.y)/8;
		}
		else{
		var pY = ns ? pageYOffset + innerHeight : document.body.scrollTop + document.body.clientHeight;
		ftlObj.y += (pY - startY - ftlObj.y)/8;
		}
		ftlObj.sP(ftlObj.x, ftlObj.y);
		setTimeout("stayTopLeft()", 10);
	}
	ftlObj = ml("divStayTopLeft");
	stayTopLeft();
}
JSFX_FloatTopDiv();
</script>
</body>
</html>
